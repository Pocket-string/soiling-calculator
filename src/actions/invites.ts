'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { createServiceClient } from '@/lib/supabase/server'
import { requireAdmin } from '@/lib/auth'
import { serverEnv } from '@/lib/env'
import { sendInviteLinkEmail } from '@/lib/email/resend'
import { consumeInviteSchema } from '@/features/invites/types/schemas'
import type { Invite } from '@/features/invites/types'
import type { Lead } from '@/features/leads/types'
import { track } from '@/lib/tracking'

// ── Create Invite ────────────────────────────────────────────────────────────

export async function createInvite(
  leadId: string,
): Promise<{ inviteUrl: string | null; emailSent: boolean; error: string | null }> {
  const admin = await requireAdmin()

  const supabase = createServiceClient()

  // 1. Fetch lead
  const { data: lead, error: fetchError } = await supabase
    .from('leads')
    .select('*')
    .eq('id', leadId)
    .single()

  if (fetchError || !lead) {
    return { inviteUrl: null, emailSent: false, error: 'Lead no encontrado.' }
  }

  const typedLead = lead as Lead

  // 2. Validate status
  if (typedLead.status !== 'applied' && typedLead.status !== 'qualified') {
    return {
      inviteUrl: null,
      emailSent: false,
      error: `Este lead ya fue procesado (status: ${typedLead.status}).`,
    }
  }

  // 3. Expire previous pending invites for same lead
  await supabase
    .from('invites')
    .update({ status: 'expired' })
    .eq('lead_id', leadId)
    .eq('status', 'pending')

  // 4. Insert new invite (token auto-generated by DB default)
  const { data: invite, error: insertError } = await supabase
    .from('invites')
    .insert({
      lead_id: leadId,
      email: typedLead.email,
      name: typedLead.name,
      access_level: 'founding',
      max_plants: 1,
      created_by: admin.id,
    })
    .select('*')
    .single()

  if (insertError || !invite) {
    console.error('[createInvite] Insert error:', insertError)
    return { inviteUrl: null, emailSent: false, error: `Error creando invitación: ${insertError?.message}` }
  }

  const typedInvite = invite as Invite

  // 5. Update lead status → invited
  await supabase
    .from('leads')
    .update({ status: 'invited' })
    .eq('id', leadId)

  // 6. Build invite URL
  const baseUrl = serverEnv.NEXT_PUBLIC_SITE_URL
  const inviteUrl = `${baseUrl}/invite/${typedInvite.token}`

  // 7. Send email (graceful)
  let emailSent = false
  const emailResult = await sendInviteLinkEmail({
    to: typedLead.email,
    name: typedLead.name,
    inviteUrl,
  })

  if (!emailResult.error) {
    emailSent = true
  } else {
    console.warn('[createInvite] Email error (no bloqueante):', emailResult.error)
  }

  // 8. Track funnel event
  track({ event: 'LEAD_INVITED', userId: admin.id, leadId, metadata: { email: typedLead.email } })

  // 9. Revalidate
  revalidatePath('/panel/leads')

  return { inviteUrl, emailSent, error: null }
}

// ── Get Invite by Token ──────────────────────────────────────────────────────

export async function getInviteByToken(
  token: string,
): Promise<{ invite: Invite | null; error: string | null }> {
  const supabase = createServiceClient()

  const { data, error } = await supabase
    .from('invites')
    .select('*')
    .eq('token', token)
    .single()

  if (error || !data) {
    return { invite: null, error: 'Invitación no encontrada.' }
  }

  const invite = data as Invite

  if (invite.status === 'consumed') {
    return { invite: null, error: 'Esta invitación ya fue utilizada.' }
  }

  if (invite.status === 'expired' || new Date(invite.expires_at) < new Date()) {
    return { invite: null, error: 'Esta invitación ha expirado.' }
  }

  return { invite, error: null }
}

// ── Consume Invite ───────────────────────────────────────────────────────────

interface ConsumeInviteState {
  error: string | null
  fieldErrors: Record<string, string[]>
}

export async function consumeInvite(
  _prevState: ConsumeInviteState,
  formData: FormData,
): Promise<ConsumeInviteState> {
  const raw = {
    token: formData.get('token') as string,
    full_name: formData.get('full_name') as string,
    password: formData.get('password') as string,
  }

  // 1. Validate input
  const parsed = consumeInviteSchema.safeParse(raw)
  if (!parsed.success) {
    return {
      error: null,
      fieldErrors: parsed.error.flatten().fieldErrors as Record<string, string[]>,
    }
  }

  const { token, full_name, password } = parsed.data

  const supabase = createServiceClient()

  // 2. Fetch invite
  const { data: inviteData, error: fetchError } = await supabase
    .from('invites')
    .select('*')
    .eq('token', token)
    .single()

  if (fetchError || !inviteData) {
    return { error: 'Invitación no encontrada.', fieldErrors: {} }
  }

  const invite = inviteData as Invite

  if (invite.status !== 'pending') {
    return { error: 'Esta invitación ya fue utilizada.', fieldErrors: {} }
  }

  if (new Date(invite.expires_at) < new Date()) {
    return { error: 'Esta invitación ha expirado.', fieldErrors: {} }
  }

  // 3. Create auth user
  const { data: authData, error: authError } = await supabase.auth.admin.createUser({
    email: invite.email,
    password,
    email_confirm: true,
    user_metadata: { name: full_name, source: 'invite' },
  })

  if (authError) {
    if (authError.message?.includes('already been registered')) {
      return { error: `Ya existe una cuenta con el email ${invite.email}.`, fieldErrors: {} }
    }
    console.error('[consumeInvite] Auth error:', authError)
    return { error: `Error creando cuenta: ${authError.message}`, fieldErrors: {} }
  }

  if (!authData.user) {
    return { error: 'Error inesperado: usuario no creado.', fieldErrors: {} }
  }

  // 4. Create profile
  const trialEndsAt = invite.access_level === 'founding'
    ? new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
    : null

  const { error: profileError } = await supabase
    .from('profiles')
    .insert({
      id: authData.user.id,
      full_name,
      access_level: invite.access_level,
      trial_ends_at: trialEndsAt,
      max_plants: invite.max_plants,
    })

  if (profileError) {
    console.error('[consumeInvite] Profile error:', profileError)
  }

  // 5. Also insert into legacy users table for backward compatibility
  const { error: userError } = await supabase
    .from('users')
    .upsert({ id: authData.user.id, trial_ends_at: trialEndsAt })

  if (userError) {
    console.error('[consumeInvite] Users table error:', userError)
  }

  // 6. Mark invite as consumed
  await supabase
    .from('invites')
    .update({ status: 'consumed', consumed_at: new Date().toISOString() })
    .eq('id', invite.id)

  // 7. Update lead status → active
  await supabase
    .from('leads')
    .update({ status: 'active' })
    .eq('id', invite.lead_id)

  // 8. Track funnel event
  track({ event: 'INVITE_CONSUMED', userId: authData.user.id, leadId: invite.lead_id, metadata: { email: invite.email } })

  // 9. Revalidate
  revalidatePath('/panel/leads')

  // 10. Redirect to login (user needs to log in with their new credentials)
  redirect('/login?registered=true')
}
